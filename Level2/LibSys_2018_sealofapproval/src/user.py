import Level2.LibSys_2018_sealofapproval.src.item_list as s


class User():
	"""
	User class for creating and managing a user of library manager
	Relies on item_list class

	"""

	def __init__(self, id):
		"""
		Initialise a user with a given ID number and initial fine which will be 0
		:param: id: user ID generated by library and given to user and assigned in init, int
		"""

		self.user_id = id  # assign id
		self.fines = 0  # set initial fine of user to 0
		self.user_item_list = s.ItemList()  # create users item list instance

	def __del__(self):
		"""
		Clean up the user if they leave library

		:return: NA
		"""

		# assume to delete to just attributes to None
		self.user_id = None
		self.fines = None
		self.user_item_list = None

	def able_to_borrow(self, maxfines, maxallowed):
		"""
		Check whether a user is able to borrow an item by checking their fines and borrowed items
		agains the max allowed for a user

		:param: maxfines: max amount of fines allowed, float
		:param: maxallowed: max amount of items allowed to checkout, int
		:return: boolean
		"""

		# if user has fines > than max fines or num of items > max allowed then can't borrow
		if ((self.user_item_list.fines_owed() + self.fines) > maxfines):
			raise(max_fine_error.MaxFinesError)
		elif (self.user_item_list.number_of_items() > maxallowed):
			raise(except_too_many_items.TooManyCooksError)
		else:  # can borrow
			return True

	def checkout(self, item):
		"""
		Checkout an item for user, passes item to item list to check it out to users item list

		:param item: item object that is to be checked out
		:return: NA
		"""

		try:  # try and check it out if its available to do so
			self.user_item_list.checkout(item)  # pass item to users item list
		except:  # exception raised if item not available
			raise  # raise exception back to user list

	def return_item(self, itemid):
		"""
		Return item back to library for current user

		:param: itemid: ID of item to be returned, string or int
		:return: NA
		"""

		# Pass item to users item list to be returned and get updated fines
		self.fines += self.user_item_list.return_item(itemid)

	def get_id(self):
		"""
		Return user id

		:return: user id
		"""

		# return the user id
		return self.user_id

	def get_fines(self):
		"""
		Return the fines owed for user id

		:param user_id: user id, flaot
		:return: return the fines owed for user
		"""

		return self.fines

	def pay_fines(self, amount):
		"""
		Pay the user fine by subtracting an amount from the users fine

		:param: amount: an amount to pay off, float
		:return: NA
		"""

		self.fines -= amount